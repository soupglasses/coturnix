From 7792cd7239a8e5580235008d4e55f3b8d665b77b Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Tue, 16 Jan 2024 16:41:39 +0100
Subject: [PATCH] draft: implement drm leasing service

monitor-config-manager: Use autoptr in more cases

native/crtc-kms: Add a way to query the assigned primary plane

kms/connector: Add 'for-lease' getter

This is intended to be used to filter out what connectors will be
available for lease, i.e. non-desktop ones.

Co-authored-by: Sebastian Wick <sebastian.wick@redhat.com>

kms: Add 'device-added' signal

This signals when there was a mode setting device added.

monitor-config-manager: Consider leased CRTCs assigned

With leasing, we will give another client control over connectors but
they also need a CRTC to drive them. Those CRTCs won't be available to
the desktop/monitor-manager.

Co-authored-by: Sebastian Wick <sebastian.wick@redhat.com>

kms-device-impl: Implement leasing, revoking and listing leases

The lease_objects function takes connectors, CRTCs and planes which are
turned into a drm lease. The resulting lease can be revoked with
revoke_lease. With list_lessees the currently active leases can be
queried.

Co-authored-by: Sebastian Wick <sebastian.wick@redhat.com>

udev: Listen for lease events

Lease events are sent when drm leases disappear. This event will help us
track leased out drm resources.

native/crtc-kms: Unset config of CRTCs which are not part of a modeset

This allows us to keep track when primary and cursor plane assignments
on a CRTC are unassigned. With this commit, all planes which are
assigned are actually in use and can't be assigned to anything else.

We'll make use of that fact when we search for a leasable primary plane.

native/crtc-kms: Don't assign leased primary planes to CRTCs

When a plane is leased, it is assigned to a CRTC which is leased. When
trying to find a primary plane for a modeset, skip the assigned planes
on leased CRTCs to avoid sharing the resources with the leased process.

native/kms-lease: Implement leasing out a set of connectors

The manager keeps track of which connectors are leasable in general,
which connectors and resources are already part of a lease, and keeps
track of when leases get revoked.

When leasing out connectors, the required drm resources to drive the
connectors are included in the lease as well.

drm-leasing-service: Implement a D-Bus service to manage drm leases

backend: Create the drm leasing service
---
 .../org.gnome.Mutter.DrmLease.xml             |  37 +
 src/backends/meta-backend.c                   |   4 +
 src/backends/meta-crtc.c                      |  15 +
 src/backends/meta-crtc.h                      |   6 +
 src/backends/meta-drm-leasing-service.c       | 298 +++++++
 src/backends/meta-drm-leasing-service.h       |  29 +
 src/backends/meta-monitor-config-manager.c    |  22 +-
 src/backends/native/meta-crtc-kms.c           |  60 ++
 src/backends/native/meta-crtc-kms.h           |   6 +
 src/backends/native/meta-gpu-kms.c            |   7 +-
 src/backends/native/meta-kms-connector.c      |  19 +
 src/backends/native/meta-kms-connector.h      |  13 +
 src/backends/native/meta-kms-crtc-private.h   |   3 +
 src/backends/native/meta-kms-crtc.c           |  15 +
 src/backends/native/meta-kms-crtc.h           |   2 +
 src/backends/native/meta-kms-device.c         | 140 ++++
 src/backends/native/meta-kms-device.h         |  17 +
 src/backends/native/meta-kms-impl-device.c    | 238 ++++--
 src/backends/native/meta-kms-impl-device.h    |  17 +
 src/backends/native/meta-kms-lease.c          | 791 ++++++++++++++++++
 src/backends/native/meta-kms-lease.h          |  53 ++
 src/backends/native/meta-kms.c                |  33 +
 src/backends/native/meta-udev.c               |  11 +
 src/meson.build                               |   9 +
 24 files changed, 1773 insertions(+), 72 deletions(-)
 create mode 100644 data/dbus-interfaces/org.gnome.Mutter.DrmLease.xml
 create mode 100644 src/backends/meta-drm-leasing-service.c
 create mode 100644 src/backends/meta-drm-leasing-service.h
 create mode 100644 src/backends/native/meta-kms-lease.c
 create mode 100644 src/backends/native/meta-kms-lease.h

diff --git a/data/dbus-interfaces/org.gnome.Mutter.DrmLease.xml b/data/dbus-interfaces/org.gnome.Mutter.DrmLease.xml
new file mode 100644
index 000000000..b81d2d242
--- /dev/null
+++ b/data/dbus-interfaces/org.gnome.Mutter.DrmLease.xml
@@ -0,0 +1,37 @@
+<!DOCTYPE node PUBLIC
+'-//freedesktop//DTD D-BUS Object Introspection 1.0//EN'
+'http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd'>
+<node>
+  <!--
+      org.gnome.Mutter.DrmLease:
+      @short_description: Interface for DRM leasing
+
+      This API is private and not intended to be used outside of the integrated
+      system that uses libmutter. No compatibility between versions is
+      promised.
+  -->
+
+  <interface name="org.gnome.Mutter.DrmLease">
+    <method name="GetConnectors">
+      <arg name="connectors" direction="out" type="a(uus)"/>
+    </method>
+
+    <method name="CreateLease">
+      <arg name="connectors" direction="in" type="au"/>
+      <arg name="id" direction="out" type="u"/>
+      <annotation name="org.gtk.GDBus.C.UnixFD" value="true"/>
+      <arg name="fd" direction="out" type="h"/>"
+    </method>
+
+    <method name="RevokeLease">
+      <arg name="id" direction="in" type="u"/>
+    </method>
+
+    <signal name="ConnectorsChanged">
+    </signal>
+
+    <signal name="LeaseRevoked">
+      <arg name="id" direction="in" type="u"/>
+    </signal>
+  </interface>
+</node>"
diff --git a/src/backends/meta-backend.c b/src/backends/meta-backend.c
index 0fb880fab..af142794c 100644
--- a/src/backends/meta-backend.c
+++ b/src/backends/meta-backend.c
@@ -56,6 +56,7 @@
 #include "backends/meta-cursor-renderer.h"
 #include "backends/meta-cursor-tracker-private.h"
 #include "backends/meta-dbus-session-watcher.h"
+#include "backends/meta-drm-leasing-service.h"
 #include "backends/meta-idle-manager.h"
 #include "backends/meta-idle-monitor-private.h"
 #include "backends/meta-input-capture.h"
@@ -136,6 +137,7 @@ struct _MetaBackendPrivate
   MetaIdleManager *idle_manager;
   MetaRenderer *renderer;
   MetaColorManager *color_manager;
+  MetaKmsLeasingService *kms_leasing_service;
 #ifdef HAVE_EGL
   MetaEgl *egl;
 #endif
@@ -218,6 +220,7 @@ meta_backend_dispose (GObject *object)
   g_clear_object (&priv->input_capture);
   g_clear_object (&priv->dbus_session_watcher);
   g_clear_object (&priv->remote_access_controller);
+  g_clear_object (&priv->kms_leasing_service);
 
 #ifdef HAVE_LIBWACOM
   g_clear_pointer (&priv->wacom_db, libwacom_database_destroy);
@@ -584,6 +587,7 @@ meta_backend_real_post_init (MetaBackend *backend)
     META_DBUS_SESSION_MANAGER (priv->remote_desktop));
 #endif /* HAVE_REMOTE_DESKTOP */
 
+  priv->kms_leasing_service = meta_kms_leasing_service_new (backend);
   priv->input_capture = meta_input_capture_new (backend);
   meta_remote_access_controller_add (
     priv->remote_access_controller,
diff --git a/src/backends/meta-crtc.c b/src/backends/meta-crtc.c
index 646a508b9..71b9bcbe9 100644
--- a/src/backends/meta-crtc.c
+++ b/src/backends/meta-crtc.c
@@ -130,6 +130,10 @@ void
 meta_crtc_unset_config (MetaCrtc *crtc)
 {
   MetaCrtcPrivate *priv = meta_crtc_get_instance_private (crtc);
+  MetaCrtcClass *klass = META_CRTC_GET_CLASS (crtc);
+
+  if (klass->unset_config)
+    klass->unset_config (crtc);
 
   g_clear_pointer (&priv->config, g_free);
 }
@@ -470,3 +474,14 @@ meta_crtc_config_new (graphene_rect_t      *layout,
 
   return config;
 }
+
+gboolean
+meta_crtc_is_leased (MetaCrtc *crtc)
+{
+  MetaCrtcClass *klass = META_CRTC_GET_CLASS (crtc);
+
+  if (klass->is_leased)
+    return klass->is_leased (crtc);
+  else
+    return FALSE;
+}
diff --git a/src/backends/meta-crtc.h b/src/backends/meta-crtc.h
index 0b1eb8b67..3c6abfe35 100644
--- a/src/backends/meta-crtc.h
+++ b/src/backends/meta-crtc.h
@@ -55,6 +55,10 @@ struct _MetaCrtcClass
   void (* set_config) (MetaCrtc             *crtc,
                        const MetaCrtcConfig *config,
                        gpointer              backend_private);
+
+  void (* unset_config) (MetaCrtc *crtc);
+
+  gboolean (* is_leased) (MetaCrtc *crtc);
 };
 
 META_EXPORT_TEST
@@ -132,4 +136,6 @@ MetaCrtcConfig * meta_crtc_config_new (graphene_rect_t      *layout,
                                        MetaCrtcMode         *mode,
                                        MetaMonitorTransform  transform);
 
+gboolean meta_crtc_is_leased (MetaCrtc *crtc);
+
 G_DEFINE_AUTOPTR_CLEANUP_FUNC (MetaGammaLut, meta_gamma_lut_free)
diff --git a/src/backends/meta-drm-leasing-service.c b/src/backends/meta-drm-leasing-service.c
new file mode 100644
index 000000000..b514275da
--- /dev/null
+++ b/src/backends/meta-drm-leasing-service.c
@@ -0,0 +1,298 @@
+/*
+ * Copyright (C) 2023 Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "config.h"
+
+#include "backends/meta-drm-leasing-service.h"
+
+#include "backends/native/meta-kms-connector.h"
+#include "backends/native/meta-kms-lease.h"
+
+#define META_DRM_LEASE_DBUS_SERVICE "org.gnome.Mutter.DrmLease"
+#define META_DRM_LEASE_DBUS_PATH "/org/gnome/Mutter/DrmLease"
+
+struct _MetaKmsLeasingService
+{
+  MetaDBusDrmLeaseSkeleton parent;
+  MetaKmsLeaseManager *manager;
+
+  guint dbus_name_id;
+  gulong connectors_changed_handler_id;
+};
+
+static void meta_kms_leasing_service_init_iface (MetaDBusDrmLeaseIface *iface);
+
+G_DEFINE_TYPE_WITH_CODE (MetaKmsLeasingService, meta_kms_leasing_service,
+                         META_DBUS_TYPE_DRM_LEASE_SKELETON,
+                         G_IMPLEMENT_INTERFACE (META_DBUS_TYPE_DRM_LEASE,
+                                                meta_kms_leasing_service_init_iface))
+
+static gboolean
+handle_get_connectors (MetaDBusDrmLease      *object,
+                       GDBusMethodInvocation *invocation)
+{
+  MetaKmsLeasingService *leasing_service = META_KMS_LEASING_SERVICE (object);
+  MetaKmsLeaseManager *manager = leasing_service->manager;
+  g_autoptr (GList) connectors;
+  GList *l;
+  GVariantBuilder response;
+
+  g_variant_builder_init (&response, G_VARIANT_TYPE ("a(uus)"));
+
+  connectors = meta_kms_lease_manager_get_connectors (manager);
+  for (l = connectors; l; l = l->next)
+    {
+      MetaKmsConnector *connector = l->data;
+      MetaKmsLease *lease;
+
+      lease = meta_kms_lease_manager_get_lease_from_connector (manager,
+                                                               connector);
+
+      g_variant_builder_add (&response, "(uus)",
+                             meta_kms_connector_get_id (connector),
+                             lease ? meta_kms_lease_get_id (lease) : 0,
+                             meta_kms_connector_get_name (connector));
+    }
+
+  meta_dbus_drm_lease_complete_get_connectors (object, invocation,
+                                               g_variant_builder_end (&response));
+
+  return G_DBUS_METHOD_INVOCATION_HANDLED;
+}
+
+static void
+on_lease_revoked (MetaKmsLease          *lease,
+                  MetaKmsLeasingService *leasing_service)
+{
+  MetaDBusDrmLease *skeleton = META_DBUS_DRM_LEASE (leasing_service);
+
+  g_signal_handlers_disconnect_by_func (lease,
+                                        on_lease_revoked,
+                                        leasing_service);
+
+  meta_dbus_drm_lease_emit_lease_revoked (skeleton,
+                                          meta_kms_lease_get_id (lease));
+}
+
+static gboolean
+handle_create_lease (MetaDBusDrmLease      *object,
+                     GDBusMethodInvocation *invocation,
+                     GUnixFDList           *fd_list,
+                     GVariant              *arg_connectors)
+{
+  MetaKmsLeasingService *leasing_service = META_KMS_LEASING_SERVICE (object);
+  MetaKmsLeaseManager *manager = leasing_service->manager;
+  GVariantIter iter;
+  uint32_t connector_id;
+  g_autoptr (GList) connectors = NULL;
+  g_autoptr (MetaKmsLease) lease = NULL;
+  g_autoptr (GError) error = NULL;
+  g_autoptr (GUnixFDList) out_fd_list = NULL;
+  int fd_id;
+  int fd;
+
+  g_variant_iter_init (&iter, arg_connectors);
+  while (g_variant_iter_next (&iter, "u", &connector_id))
+    {
+      MetaKmsConnector *connector;
+
+      connector = meta_kms_lease_manager_get_connector_from_id (manager,
+                                                                connector_id);
+      if (!connector)
+        {
+          g_dbus_method_invocation_return_error (invocation,
+                                                 G_DBUS_ERROR,
+                                                 G_DBUS_ERROR_NOT_SUPPORTED,
+                                                 "Unknown connectors");
+          return G_DBUS_METHOD_INVOCATION_HANDLED;
+        }
+
+      connectors = g_list_append (connectors, connector);
+    }
+
+  lease = meta_kms_lease_manager_lease_connectors (manager, connectors, &error);
+  if (!lease)
+    {
+      g_dbus_method_invocation_return_error (invocation,
+                                             G_DBUS_ERROR,
+                                             G_DBUS_ERROR_NOT_SUPPORTED,
+                                             "Failed to lease: %s",
+                                             error->message);
+      return G_DBUS_METHOD_INVOCATION_HANDLED;
+    }
+
+  g_signal_connect (lease, "revoked", G_CALLBACK (on_lease_revoked),
+                    leasing_service);
+
+  fd = meta_kms_lease_steal_fd (lease);
+
+  out_fd_list = g_unix_fd_list_new ();
+  fd_id = g_unix_fd_list_append (out_fd_list, fd, &error);
+  if (fd_id == -1)
+    {
+      g_dbus_method_invocation_return_error (invocation,
+                                             G_DBUS_ERROR,
+                                             G_DBUS_ERROR_NOT_SUPPORTED,
+                                             "Failed to append fd: %s",
+                                             error->message);
+      return G_DBUS_METHOD_INVOCATION_HANDLED;
+    }
+
+  meta_dbus_drm_lease_complete_create_lease (object,
+                                             invocation,
+                                             out_fd_list,
+                                             meta_kms_lease_get_id (lease),
+                                             g_variant_new_handle (fd_id));
+  close (fd);
+  return G_DBUS_METHOD_INVOCATION_HANDLED;
+}
+
+static gboolean
+handle_revoke_lease (MetaDBusDrmLease      *object,
+                     GDBusMethodInvocation *invocation,
+                     guint                  arg_id)
+{
+  MetaKmsLeasingService *leasing_service = META_KMS_LEASING_SERVICE (object);
+  MetaKmsLeaseManager *manager = leasing_service->manager;
+  MetaKmsLease *lease;
+
+  lease = meta_kms_lease_manager_get_lease_from_id (manager, arg_id);
+  if (!lease)
+    {
+      g_dbus_method_invocation_return_error (invocation,
+                                             G_DBUS_ERROR,
+                                             G_DBUS_ERROR_NOT_SUPPORTED,
+                                             "Unknown lease");
+      return G_DBUS_METHOD_INVOCATION_HANDLED;
+    }
+
+  meta_kms_lease_revoke (lease);
+
+  meta_dbus_drm_lease_complete_revoke_lease (object, invocation);
+  return G_DBUS_METHOD_INVOCATION_HANDLED;
+}
+
+static void
+meta_kms_leasing_service_init_iface (MetaDBusDrmLeaseIface *iface)
+{
+  iface->handle_get_connectors = handle_get_connectors;
+  iface->handle_create_lease = handle_create_lease;
+  iface->handle_revoke_lease = handle_revoke_lease;
+}
+
+static void
+on_bus_acquired (GDBusConnection *connection,
+                 const char      *name,
+                 gpointer         user_data)
+{
+  MetaKmsLeasingService *leasing_service = user_data;
+  GDBusInterfaceSkeleton *interface_skeleton =
+    G_DBUS_INTERFACE_SKELETON (leasing_service);
+  g_autoptr (GError) error = NULL;
+
+  if (!g_dbus_interface_skeleton_export (interface_skeleton,
+                                         connection,
+                                         META_DRM_LEASE_DBUS_PATH,
+                                         &error))
+    g_warning ("Failed to export drm lease object: %s", error->message);
+}
+
+static void
+on_name_acquired (GDBusConnection *connection,
+                  const char      *name,
+                  gpointer         user_data)
+{
+  meta_topic (META_DEBUG_DBUS, "Acquired name %s", name);
+}
+
+static void
+on_name_lost (GDBusConnection *connection,
+              const char      *name,
+              gpointer         user_data)
+{
+  meta_topic (META_DEBUG_DBUS, "Lost or failed to acquire name %s", name);
+}
+
+static void
+on_connectors_changed (MetaKmsLeaseManager   *lease_manager,
+                       MetaKmsLeasingService *leasing_service)
+{
+  MetaDBusDrmLease *skeleton = META_DBUS_DRM_LEASE (leasing_service);
+
+  meta_dbus_drm_lease_emit_connectors_changed (skeleton);
+}
+
+static void
+meta_kms_leasing_service_dispose (GObject *object)
+{
+  MetaKmsLeasingService *leasing_service = META_KMS_LEASING_SERVICE (object);
+
+  g_clear_handle_id (&leasing_service->dbus_name_id, g_bus_unown_name);
+
+  g_clear_signal_handler (&leasing_service->connectors_changed_handler_id,
+                          leasing_service->manager);
+
+  g_clear_object (&leasing_service->manager);
+
+  G_OBJECT_CLASS (meta_kms_leasing_service_parent_class)->dispose (object);
+}
+
+static void
+meta_kms_leasing_service_class_init (MetaKmsLeasingServiceClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->dispose = meta_kms_leasing_service_dispose;
+}
+
+static void
+meta_kms_leasing_service_init (MetaKmsLeasingService *leasing_service)
+{
+}
+
+MetaKmsLeasingService *
+meta_kms_leasing_service_new (MetaBackend *backend)
+{
+  MetaKmsLeasingService *leasing_service;
+
+  if (!META_IS_BACKEND_NATIVE (backend))
+    return NULL;
+
+  leasing_service = g_object_new (META_TYPE_KMS_LEASING_SERVICE, NULL);
+  leasing_service->manager =
+    g_object_new (META_TYPE_KMS_LEASE_MANAGER,
+                  "backend-native", META_BACKEND_NATIVE (backend),
+                  NULL);
+
+  leasing_service->dbus_name_id =
+    g_bus_own_name (G_BUS_TYPE_SESSION,
+                    META_DRM_LEASE_DBUS_SERVICE,
+                    G_BUS_NAME_OWNER_FLAGS_NONE,
+                    on_bus_acquired,
+                    on_name_acquired,
+                    on_name_lost,
+                    leasing_service,
+                    NULL);
+
+  leasing_service->connectors_changed_handler_id =
+    g_signal_connect (leasing_service->manager, "connectors-changed",
+                      G_CALLBACK (on_connectors_changed),
+                      leasing_service);
+
+  return leasing_service;
+}
diff --git a/src/backends/meta-drm-leasing-service.h b/src/backends/meta-drm-leasing-service.h
new file mode 100644
index 000000000..353ab3a0d
--- /dev/null
+++ b/src/backends/meta-drm-leasing-service.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2023 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include "backends/meta-backend-types.h"
+
+#include "meta-dbus-drm-lease.h"
+
+#define META_TYPE_KMS_LEASING_SERVICE (meta_kms_leasing_service_get_type ())
+G_DECLARE_FINAL_TYPE (MetaKmsLeasingService, meta_kms_leasing_service,
+                      META, KMS_LEASING_SERVICE,
+                      MetaDBusDrmLeaseSkeleton)
+
+MetaKmsLeasingService * meta_kms_leasing_service_new (MetaBackend *backend);
diff --git a/src/backends/meta-monitor-config-manager.c b/src/backends/meta-monitor-config-manager.c
index 5fcb10b4e..f84f64485 100644
--- a/src/backends/meta-monitor-config-manager.c
+++ b/src/backends/meta-monitor-config-manager.c
@@ -99,6 +99,9 @@ is_crtc_assigned (MetaCrtc  *crtc,
 {
   unsigned int i;
 
+  if (meta_crtc_is_leased (crtc))
+    return TRUE;
+
   for (i = 0; i < crtc_assignments->len; i++)
     {
       MetaCrtcAssignment *assigned_crtc_assignment =
@@ -383,9 +386,9 @@ meta_monitor_config_manager_assign (MetaMonitorManager *manager,
                                     GPtrArray         **out_output_assignments,
                                     GError            **error)
 {
-  GPtrArray *crtc_assignments;
-  GPtrArray *output_assignments;
-  GArray *reserved_crtcs;
+  g_autoptr (GPtrArray) crtc_assignments = NULL;
+  g_autoptr (GPtrArray) output_assignments = NULL;
+  g_autoptr (GArray) reserved_crtcs = NULL;
   GList *l;
 
   crtc_assignments =
@@ -432,18 +435,11 @@ meta_monitor_config_manager_assign (MetaMonitorManager *manager,
                                          config, logical_monitor_config,
                                          crtc_assignments, output_assignments,
                                          reserved_crtcs, error))
-        {
-          g_ptr_array_free (crtc_assignments, TRUE);
-          g_ptr_array_free (output_assignments, TRUE);
-          g_array_free (reserved_crtcs, TRUE);
-          return FALSE;
-        }
+        return FALSE;
     }
 
-  g_array_free (reserved_crtcs, TRUE);
-
-  *out_crtc_assignments = crtc_assignments;
-  *out_output_assignments = output_assignments;
+  *out_crtc_assignments = g_steal_pointer (&crtc_assignments);
+  *out_output_assignments = g_steal_pointer (&output_assignments);
 
   return TRUE;
 }
diff --git a/src/backends/native/meta-crtc-kms.c b/src/backends/native/meta-crtc-kms.c
index 3498f922a..ad4c9e5d0 100644
--- a/src/backends/native/meta-crtc-kms.c
+++ b/src/backends/native/meta-crtc-kms.c
@@ -206,6 +206,15 @@ meta_crtc_kms_set_gamma_lut (MetaCrtc           *crtc,
   clutter_stage_schedule_update (CLUTTER_STAGE (stage));
 }
 
+static gboolean
+meta_crtc_kms_is_leased (MetaCrtc *crtc)
+{
+  MetaCrtcKms *crtc_kms = META_CRTC_KMS (crtc);
+  MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
+
+  return meta_kms_crtc_is_leased (kms_crtc);
+}
+
 typedef struct _CrtcKmsAssignment
 {
   MetaKmsPlane *primary_plane;
@@ -247,6 +256,25 @@ is_plane_assigned (MetaKmsPlane     *plane,
   return FALSE;
 }
 
+static gboolean
+is_plane_leased (MetaKmsDevice *kms_device,
+                 MetaKmsPlane  *kms_plane)
+{
+  GList *l;
+
+  for (l = meta_kms_device_get_crtcs (kms_device); l; l = l->next)
+    {
+      MetaKmsCrtc *kms_crtc = l->data;
+      MetaCrtcKms *crtc_kms = meta_crtc_kms_from_kms_crtc (kms_crtc);
+
+      if (meta_kms_crtc_is_leased (kms_crtc) &&
+          crtc_kms->assigned_primary_plane == kms_plane)
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
 static MetaKmsPlane *
 find_unassigned_plane (MetaCrtcKms      *crtc_kms,
                        MetaKmsPlaneType  kms_plane_type,
@@ -270,6 +298,9 @@ find_unassigned_plane (MetaCrtcKms      *crtc_kms,
                              crtc_assignments))
         continue;
 
+      if (is_plane_leased (kms_device, kms_plane))
+        continue;
+
       return kms_plane;
     }
 
@@ -326,6 +357,27 @@ meta_crtc_kms_set_config (MetaCrtc             *crtc,
   crtc_kms->assigned_cursor_plane = kms_assignment->cursor_plane;
 }
 
+void
+meta_crtc_kms_assign_plane (MetaCrtcKms  *crtc_kms,
+                            MetaKmsPlane *primary_plane,
+                            MetaKmsPlane *cursor_plane)
+{
+  crtc_kms->assigned_primary_plane = primary_plane;
+  crtc_kms->assigned_cursor_plane = cursor_plane;
+}
+
+static void
+meta_crtc_kms_unset_config (MetaCrtc *crtc)
+{
+  MetaCrtcKms *crtc_kms = META_CRTC_KMS (crtc);
+
+  if (meta_crtc_kms_is_leased (crtc))
+    return;
+
+  crtc_kms->assigned_primary_plane = NULL;
+  crtc_kms->assigned_cursor_plane = NULL;
+}
+
 static gboolean
 meta_crtc_kms_is_transform_handled (MetaCrtcNative       *crtc_native,
                                     MetaMonitorTransform  transform)
@@ -348,6 +400,12 @@ meta_crtc_kms_is_hw_cursor_supported (MetaCrtcNative *crtc_native)
   return meta_kms_device_has_cursor_plane_for (kms_device, kms_crtc);
 }
 
+MetaKmsPlane *
+meta_crtc_kms_get_assigned_primary_plane (MetaCrtcKms *crtc_kms)
+{
+  return crtc_kms->assigned_primary_plane;
+}
+
 MetaKmsPlane *
 meta_crtc_kms_get_assigned_cursor_plane (MetaCrtcKms *crtc_kms)
 {
@@ -476,6 +534,8 @@ meta_crtc_kms_class_init (MetaCrtcKmsClass *klass)
   crtc_class->set_gamma_lut = meta_crtc_kms_set_gamma_lut;
   crtc_class->assign_extra = meta_crtc_kms_assign_extra;
   crtc_class->set_config = meta_crtc_kms_set_config;
+  crtc_class->unset_config = meta_crtc_kms_unset_config;
+  crtc_class->is_leased = meta_crtc_kms_is_leased;
 
   crtc_native_class->is_transform_handled = meta_crtc_kms_is_transform_handled;
   crtc_native_class->is_hw_cursor_supported = meta_crtc_kms_is_hw_cursor_supported;
diff --git a/src/backends/native/meta-crtc-kms.h b/src/backends/native/meta-crtc-kms.h
index c132b9907..1f974f12b 100644
--- a/src/backends/native/meta-crtc-kms.h
+++ b/src/backends/native/meta-crtc-kms.h
@@ -39,8 +39,14 @@ G_DECLARE_FINAL_TYPE (MetaCrtcKms, meta_crtc_kms,
 
 MetaKmsPlane * meta_crtc_kms_get_assigned_primary_plane (MetaCrtcKms *crtc_kms);
 
+MetaKmsPlane * meta_crtc_kms_get_assigned_primary_plane (MetaCrtcKms *crtc_kms);
+
 MetaKmsPlane * meta_crtc_kms_get_assigned_cursor_plane (MetaCrtcKms *crtc_kms);
 
+void meta_crtc_kms_assign_plane (MetaCrtcKms  *crtc_kms,
+                                 MetaKmsPlane *primary_plane,
+                                 MetaKmsPlane *cursor_plane);
+
 void meta_crtc_kms_set_mode (MetaCrtcKms   *crtc_kms,
                              MetaKmsUpdate *kms_update);
 
diff --git a/src/backends/native/meta-gpu-kms.c b/src/backends/native/meta-gpu-kms.c
index 3e0ad99c5..3b4356ca6 100644
--- a/src/backends/native/meta-gpu-kms.c
+++ b/src/backends/native/meta-gpu-kms.c
@@ -348,13 +348,14 @@ init_outputs (MetaGpuKms *gpu_kms)
   for (l = meta_kms_device_get_connectors (gpu_kms->kms_device); l; l = l->next)
     {
       MetaKmsConnector *kms_connector = l->data;
-      const MetaKmsConnectorState *connector_state;
       MetaOutputKms *output_kms;
       MetaOutput *old_output;
       GError *error = NULL;
 
-      connector_state = meta_kms_connector_get_current_state (kms_connector);
-      if (!connector_state || connector_state->non_desktop)
+      if (!meta_kms_connector_get_current_state (kms_connector))
+        continue;
+
+      if (meta_kms_connector_is_for_lease (kms_connector))
         continue;
 
       old_output =
diff --git a/src/backends/native/meta-kms-connector.c b/src/backends/native/meta-kms-connector.c
index d47d9c835..f0f05169b 100644
--- a/src/backends/native/meta-kms-connector.c
+++ b/src/backends/native/meta-kms-connector.c
@@ -171,6 +171,25 @@ has_privacy_screen_software_toggle (MetaKmsConnector *connector)
     META_KMS_CONNECTOR_PROP_PRIVACY_SCREEN_SW_STATE) != 0;
 }
 
+const MetaKmsRange *
+meta_kms_connector_get_max_bpc (MetaKmsConnector *connector)
+{
+  const MetaKmsRange *range = NULL;
+
+  if (connector->current_state &&
+      meta_kms_connector_get_prop_id (connector,
+                                      META_KMS_CONNECTOR_PROP_MAX_BPC))
+    range = &connector->current_state->max_bpc;
+
+  return range;
+}
+
+gboolean
+meta_kms_connector_is_for_lease (MetaKmsConnector *connector)
+{
+  return connector->current_state && connector->current_state->non_desktop;
+}
+
 static void
 sync_fd_held (MetaKmsConnector  *connector,
               MetaKmsImplDevice *impl_device)
diff --git a/src/backends/native/meta-kms-connector.h b/src/backends/native/meta-kms-connector.h
index cb71b4987..beccb6f5a 100644
--- a/src/backends/native/meta-kms-connector.h
+++ b/src/backends/native/meta-kms-connector.h
@@ -101,3 +101,16 @@ MetaKmsMode * meta_kms_connector_get_preferred_mode (MetaKmsConnector *connector
 
 META_EXPORT_TEST
 const MetaKmsConnectorState * meta_kms_connector_get_current_state (MetaKmsConnector *connector);
+
+gboolean meta_kms_connector_is_underscanning_supported (MetaKmsConnector *connector);
+
+gboolean meta_kms_connector_is_privacy_screen_supported (MetaKmsConnector *connector);
+
+const MetaKmsRange * meta_kms_connector_get_max_bpc (MetaKmsConnector *connector);
+
+gboolean meta_kms_connector_is_color_space_supported (MetaKmsConnector     *connector,
+                                                      MetaOutputColorspace  color_space);
+
+gboolean meta_kms_connector_is_hdr_metadata_supported (MetaKmsConnector *connector);
+
+gboolean meta_kms_connector_is_for_lease (MetaKmsConnector *connector);
diff --git a/src/backends/native/meta-kms-crtc-private.h b/src/backends/native/meta-kms-crtc-private.h
index 299482d6e..237a73625 100644
--- a/src/backends/native/meta-kms-crtc-private.h
+++ b/src/backends/native/meta-kms-crtc-private.h
@@ -58,3 +58,6 @@ gboolean meta_kms_crtc_determine_deadline (MetaKmsCrtc  *crtc,
                                            int64_t      *out_next_deadline_us,
                                            int64_t      *out_next_presentation_us,
                                            GError      **error);
+
+void meta_kms_crtc_set_is_leased (MetaKmsCrtc *crtc,
+                                  gboolean     leased);
diff --git a/src/backends/native/meta-kms-crtc.c b/src/backends/native/meta-kms-crtc.c
index a0872089a..40237fff9 100644
--- a/src/backends/native/meta-kms-crtc.c
+++ b/src/backends/native/meta-kms-crtc.c
@@ -50,6 +50,8 @@ struct _MetaKmsCrtc
   MetaKmsCrtcState current_state;
 
   MetaKmsCrtcPropTable prop_table;
+
+  gboolean is_leased;
 };
 
 G_DEFINE_TYPE (MetaKmsCrtc, meta_kms_crtc, G_TYPE_OBJECT)
@@ -107,6 +109,19 @@ meta_kms_crtc_is_active (MetaKmsCrtc *crtc)
   return crtc->current_state.is_active;
 }
 
+gboolean
+meta_kms_crtc_is_leased (MetaKmsCrtc *crtc)
+{
+  return crtc->is_leased;
+}
+
+void
+meta_kms_crtc_set_is_leased (MetaKmsCrtc *crtc,
+                             gboolean     leased)
+{
+  crtc->is_leased = leased;
+}
+
 static void
 read_crtc_gamma (MetaKmsCrtc       *crtc,
                  MetaKmsCrtcState  *crtc_state,
diff --git a/src/backends/native/meta-kms-crtc.h b/src/backends/native/meta-kms-crtc.h
index 580ee9a89..af6538cd3 100644
--- a/src/backends/native/meta-kms-crtc.h
+++ b/src/backends/native/meta-kms-crtc.h
@@ -65,3 +65,5 @@ int meta_kms_crtc_get_idx (MetaKmsCrtc *crtc);
 
 META_EXPORT_TEST
 gboolean meta_kms_crtc_is_active (MetaKmsCrtc *crtc);
+
+gboolean meta_kms_crtc_is_leased (MetaKmsCrtc *crtc);
diff --git a/src/backends/native/meta-kms-device.c b/src/backends/native/meta-kms-device.c
index 83d9f8b6d..9002480bd 100644
--- a/src/backends/native/meta-kms-device.c
+++ b/src/backends/native/meta-kms-device.c
@@ -439,6 +439,145 @@ meta_kms_device_add_fake_plane_in_impl (MetaKmsDevice    *device,
   device->planes = g_list_append (device->planes, plane);
 }
 
+typedef struct
+{
+  MetaKmsDevice *device;
+  GList *connectors;
+  GList *crtcs;
+  GList *planes;
+
+  int fd;
+  uint32_t lessee_id;
+} LeaseRequestData;
+
+static gpointer
+lease_objects_in_impl (MetaThreadImpl  *thread_impl,
+                       gpointer         user_data,
+                       GError         **error)
+{
+  LeaseRequestData *data = user_data;
+  MetaKmsImplDevice *impl_device =
+    meta_kms_device_get_impl_device (data->device);
+  uint32_t lessee_id;
+  int fd;
+
+  if (!meta_kms_impl_device_lease_objects (impl_device,
+                                           data->connectors,
+                                           data->crtcs,
+                                           data->planes,
+                                           &fd,
+                                           &lessee_id,
+                                           error))
+    return GINT_TO_POINTER (FALSE);
+
+  data->fd = fd;
+  data->lessee_id = lessee_id;
+
+  return GINT_TO_POINTER (TRUE);
+}
+
+gboolean
+meta_kms_device_lease_objects (MetaKmsDevice  *device,
+                               GList          *connectors,
+                               GList          *crtcs,
+                               GList          *planes,
+                               int            *out_fd,
+                               uint32_t       *out_lessee_id,
+                               GError        **error)
+{
+  LeaseRequestData data = {};
+
+  data.device = device;
+  data.connectors = connectors;
+  data.crtcs = crtcs;
+  data.planes = planes;
+
+  if (!meta_kms_run_impl_task_sync (device->kms, lease_objects_in_impl, &data,
+                                    error))
+    return FALSE;
+
+  *out_fd = data.fd;
+  *out_lessee_id = data.lessee_id;
+  return TRUE;
+}
+
+typedef struct
+{
+  MetaKmsDevice *device;
+  uint32_t lessee_id;
+} RevokeLeaseData;
+
+static gpointer
+revoke_lease_in_impl (MetaThreadImpl  *thread_impl,
+                      gpointer         user_data,
+                      GError         **error)
+{
+  LeaseRequestData *data = user_data;
+  MetaKmsImplDevice *impl_device =
+    meta_kms_device_get_impl_device (data->device);
+
+  if (!meta_kms_impl_device_revoke_lease (impl_device, data->lessee_id, error))
+    return GINT_TO_POINTER (FALSE);
+  else
+    return GINT_TO_POINTER (TRUE);
+}
+
+gboolean
+meta_kms_device_revoke_lease (MetaKmsDevice  *device,
+                              uint32_t        lessee_id,
+                              GError        **error)
+{
+  LeaseRequestData data = {};
+
+  data.device = device;
+  data.lessee_id = lessee_id;
+
+  return !!meta_kms_run_impl_task_sync (device->kms, revoke_lease_in_impl, &data,
+                                        error);
+}
+
+typedef struct
+{
+  MetaKmsDevice *device;
+  uint32_t **out_lessee_ids;
+  int *out_num_lessee_ids;
+} ListLesseesData;
+
+static gpointer
+list_lessees_in_impl (MetaThreadImpl  *thread_impl,
+                      gpointer         user_data,
+                      GError         **error)
+{
+  ListLesseesData *data = user_data;
+  MetaKmsImplDevice *impl_device = meta_kms_device_get_impl_device (data->device);
+
+  if (!meta_kms_impl_device_list_lessees (impl_device,
+                                          data->out_lessee_ids,
+                                          data->out_num_lessee_ids,
+                                          error))
+    return GINT_TO_POINTER (FALSE);
+  else
+    return GINT_TO_POINTER (TRUE);
+}
+
+gboolean
+meta_kms_device_list_lessees (MetaKmsDevice  *device,
+                              uint32_t      **out_lessee_ids,
+                              int            *out_num_lessee_ids,
+                              GError        **error)
+{
+  ListLesseesData data = {};
+
+  data.device = device;
+  data.out_lessee_ids = out_lessee_ids;
+  data.out_num_lessee_ids = out_num_lessee_ids;
+
+  return !!meta_kms_run_impl_task_sync (device->kms,
+                                        list_lessees_in_impl,
+                                        &data,
+                                        error);
+}
+
 typedef struct _CreateImplDeviceData
 {
   MetaKmsDevice *device;
@@ -726,3 +865,4 @@ meta_kms_device_class_init (MetaKmsDeviceClass *klass)
                   G_TYPE_NONE, 1,
                   META_TYPE_KMS_CRTC);
 }
+
diff --git a/src/backends/native/meta-kms-device.h b/src/backends/native/meta-kms-device.h
index 00dafb16c..0b39f7df5 100644
--- a/src/backends/native/meta-kms-device.h
+++ b/src/backends/native/meta-kms-device.h
@@ -86,6 +86,23 @@ gboolean meta_kms_device_handle_flush (MetaKmsDevice *device,
 META_EXPORT_TEST
 void meta_kms_device_disable (MetaKmsDevice *device);
 
+gboolean meta_kms_device_lease_objects (MetaKmsDevice  *device,
+                                        GList          *connectors,
+                                        GList          *crtcs,
+                                        GList          *planes,
+                                        int            *out_fd,
+                                        uint32_t       *out_lessee_id,
+                                        GError        **error);
+
+gboolean meta_kms_device_revoke_lease (MetaKmsDevice  *device,
+                                       uint32_t        lessee_id,
+                                       GError        **error);
+
+gboolean meta_kms_device_list_lessees (MetaKmsDevice  *device,
+                                       uint32_t      **out_lessee_ids,
+                                       int            *out_num_lessee_ids,
+                                       GError        **error);
+
 MetaKmsDevice * meta_kms_device_new (MetaKms            *kms,
                                      const char         *path,
                                      MetaKmsDeviceFlag   flags,
diff --git a/src/backends/native/meta-kms-impl-device.c b/src/backends/native/meta-kms-impl-device.c
index b15eee14d..faa32937e 100644
--- a/src/backends/native/meta-kms-impl-device.c
+++ b/src/backends/native/meta-kms-impl-device.c
@@ -243,6 +243,188 @@ meta_kms_impl_device_get_path (MetaKmsImplDevice *impl_device)
   return priv->path;
 }
 
+static MetaDeviceFile *
+meta_kms_impl_device_open_device_file (MetaKmsImplDevice  *impl_device,
+                                       const char         *path,
+                                       GError            **error)
+{
+  MetaKmsImplDevicePrivate *priv =
+    meta_kms_impl_device_get_instance_private (impl_device);
+  MetaKmsImplDeviceClass *klass = META_KMS_IMPL_DEVICE_GET_CLASS (impl_device);
+
+  return klass->open_device_file (impl_device, priv->path, error);
+}
+
+static gpointer
+kms_event_dispatch_in_impl (MetaThreadImpl  *impl,
+                            gpointer         user_data,
+                            GError         **error)
+{
+  MetaKmsImplDevice *impl_device = user_data;
+  gboolean ret;
+
+  ret = meta_kms_impl_device_dispatch (impl_device, error);
+  return GINT_TO_POINTER (ret);
+}
+
+static gboolean
+ensure_device_file (MetaKmsImplDevice  *impl_device,
+                    GError            **error)
+{
+  MetaKmsImplDevicePrivate *priv =
+    meta_kms_impl_device_get_instance_private (impl_device);
+  MetaDeviceFile *device_file;
+
+  if (priv->device_file)
+    return TRUE;
+
+  device_file = meta_kms_impl_device_open_device_file (impl_device,
+                                                       priv->path,
+                                                       error);
+  if (!device_file)
+    return FALSE;
+
+  priv->device_file = device_file;
+
+  if (!(priv->flags & META_KMS_DEVICE_FLAG_NO_MODE_SETTING))
+    {
+      priv->fd_source =
+        meta_thread_impl_register_fd (META_THREAD_IMPL (priv->impl),
+                                      meta_device_file_get_fd (device_file),
+                                      kms_event_dispatch_in_impl,
+                                      impl_device);
+      g_source_set_priority (priv->fd_source, G_PRIORITY_HIGH);
+    }
+
+  return TRUE;
+}
+
+gboolean
+meta_kms_impl_device_lease_objects (MetaKmsImplDevice  *impl_device,
+                                    GList              *connectors,
+                                    GList              *crtcs,
+                                    GList              *planes,
+                                    int                *out_fd,
+                                    uint32_t           *out_lessee_id,
+                                    GError            **error)
+{
+  MetaKmsImplDevicePrivate *priv =
+    meta_kms_impl_device_get_instance_private (impl_device);
+  uint32_t *object_ids;
+  int n_object_ids;
+  GList *l;
+  int retval;
+  uint32_t lessee_id;
+  int i = 0;
+
+  meta_assert_in_kms_impl (meta_kms_impl_get_kms (priv->impl));
+
+  if (!ensure_device_file (impl_device, error))
+    return FALSE;
+
+  meta_kms_impl_device_hold_fd (impl_device);
+
+  n_object_ids = (g_list_length (connectors) +
+                  g_list_length (crtcs) +
+                  g_list_length (planes));
+  object_ids = g_alloca (sizeof (uint32_t) * n_object_ids);
+
+  for (l = connectors; l; l = l->next)
+    {
+      MetaKmsConnector *connector = l->data;
+
+      object_ids[i++] = meta_kms_connector_get_id (connector);
+    }
+
+  for (l = crtcs; l; l = l->next)
+    {
+      MetaKmsCrtc *crtc = l->data;
+
+      object_ids[i++] = meta_kms_crtc_get_id (crtc);
+    }
+
+  for (l = planes; l; l = l->next)
+    {
+      MetaKmsPlane *plane = l->data;
+
+      object_ids[i++] = meta_kms_plane_get_id (plane);
+    }
+
+  retval = drmModeCreateLease (meta_kms_impl_device_get_fd (impl_device),
+                               object_ids, n_object_ids, 0,
+                               &lessee_id);
+
+  if (retval < 0)
+    {
+      meta_kms_impl_device_unhold_fd (impl_device);
+      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (-retval),
+                   "Failed to create lease: %s", g_strerror (-retval));
+      return FALSE;
+    }
+
+  *out_fd = retval;
+  *out_lessee_id = lessee_id;
+
+  return TRUE;
+}
+
+gboolean
+meta_kms_impl_device_revoke_lease (MetaKmsImplDevice  *impl_device,
+                                   uint32_t            lessee_id,
+                                   GError            **error)
+{
+  MetaKmsImplDevicePrivate *priv =
+    meta_kms_impl_device_get_instance_private (impl_device);
+  int retval;
+
+  meta_assert_in_kms_impl (meta_kms_impl_get_kms (priv->impl));
+
+  retval = drmModeRevokeLease (meta_kms_impl_device_get_fd (impl_device),
+                               lessee_id);
+  meta_kms_impl_device_unhold_fd (impl_device);
+
+  if (retval != 0)
+    {
+      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (-retval),
+                   "Failed to revoke lease: %s", g_strerror (-retval));
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+gboolean
+meta_kms_impl_device_list_lessees (MetaKmsImplDevice  *impl_device,
+                                   uint32_t          **out_lessee_ids,
+                                   int                *out_num_lessee_ids,
+                                   GError            **error)
+{
+  MetaKmsImplDevicePrivate *priv =
+    meta_kms_impl_device_get_instance_private (impl_device);
+  drmModeLesseeListRes *list;
+  int i;
+  uint32_t *lessee_ids;
+
+  meta_assert_in_kms_impl (meta_kms_impl_get_kms (priv->impl));
+
+  list = drmModeListLessees(meta_kms_impl_device_get_fd (impl_device));
+
+  if (!list)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Failed to list lessees");
+      return FALSE;
+    }
+
+  lessee_ids = g_malloc0 (list->count * sizeof (uint32_t));
+  for (i = 0; i < list->count; i++)
+    lessee_ids[i] = list->lessees[i];
+
+  *out_lessee_ids = lessee_ids;
+  *out_num_lessee_ids = list->count;
+  return TRUE;
+}
+
 gboolean
 meta_kms_impl_device_dispatch (MetaKmsImplDevice  *impl_device,
                                GError            **error)
@@ -293,18 +475,6 @@ meta_kms_impl_device_dispatch (MetaKmsImplDevice  *impl_device,
   return TRUE;
 }
 
-static gpointer
-kms_event_dispatch_in_impl (MetaThreadImpl  *impl,
-                            gpointer         user_data,
-                            GError         **error)
-{
-  MetaKmsImplDevice *impl_device = user_data;
-  gboolean ret;
-
-  ret = meta_kms_impl_device_dispatch (impl_device, error);
-  return GINT_TO_POINTER (ret);
-}
-
 drmModePropertyPtr
 meta_kms_impl_device_find_property (MetaKmsImplDevice       *impl_device,
                                     drmModeObjectProperties *props,
@@ -869,50 +1039,6 @@ init_fallback_modes (MetaKmsImplDevice *impl_device)
   priv->fallback_modes = g_list_reverse (modes);
 }
 
-static MetaDeviceFile *
-meta_kms_impl_device_open_device_file (MetaKmsImplDevice  *impl_device,
-                                       const char         *path,
-                                       GError            **error)
-{
-  MetaKmsImplDevicePrivate *priv =
-    meta_kms_impl_device_get_instance_private (impl_device);
-  MetaKmsImplDeviceClass *klass = META_KMS_IMPL_DEVICE_GET_CLASS (impl_device);
-
-  return klass->open_device_file (impl_device, priv->path, error);
-}
-
-static gboolean
-ensure_device_file (MetaKmsImplDevice  *impl_device,
-                    GError            **error)
-{
-  MetaKmsImplDevicePrivate *priv =
-    meta_kms_impl_device_get_instance_private (impl_device);
-  MetaDeviceFile *device_file;
-
-  if (priv->device_file)
-    return TRUE;
-
-  device_file = meta_kms_impl_device_open_device_file (impl_device,
-                                                       priv->path,
-                                                       error);
-  if (!device_file)
-    return FALSE;
-
-  priv->device_file = device_file;
-
-  if (!(priv->flags & META_KMS_DEVICE_FLAG_NO_MODE_SETTING))
-    {
-      priv->fd_source =
-        meta_thread_impl_register_fd (META_THREAD_IMPL (priv->impl),
-                                      meta_device_file_get_fd (device_file),
-                                      kms_event_dispatch_in_impl,
-                                      impl_device);
-      g_source_set_priority (priv->fd_source, G_PRIORITY_HIGH);
-    }
-
-  return TRUE;
-}
-
 static void
 ensure_latched_fd_hold (MetaKmsImplDevice *impl_device)
 {
diff --git a/src/backends/native/meta-kms-impl-device.h b/src/backends/native/meta-kms-impl-device.h
index 271ccbfd1..00d8218a4 100644
--- a/src/backends/native/meta-kms-impl-device.h
+++ b/src/backends/native/meta-kms-impl-device.h
@@ -129,6 +129,23 @@ const char * meta_kms_impl_device_get_driver_description (MetaKmsImplDevice *imp
 
 const char * meta_kms_impl_device_get_path (MetaKmsImplDevice *impl_device);
 
+gboolean meta_kms_impl_device_lease_objects (MetaKmsImplDevice  *impl_device,
+                                             GList              *connectors,
+                                             GList              *crtcs,
+                                             GList              *planes,
+                                             int                *out_fd,
+                                             uint32_t           *out_lessee_id,
+                                             GError            **error);
+
+gboolean meta_kms_impl_device_revoke_lease (MetaKmsImplDevice  *impl_device,
+                                            uint32_t            lessee_id,
+                                            GError            **error);
+
+gboolean meta_kms_impl_device_list_lessees (MetaKmsImplDevice  *impl_device,
+                                            uint32_t          **out_lessee_ids,
+                                            int                *out_num_lessee_ids,
+                                            GError            **error);
+
 gboolean meta_kms_impl_device_dispatch (MetaKmsImplDevice  *impl_device,
                                         GError            **error);
 
diff --git a/src/backends/native/meta-kms-lease.c b/src/backends/native/meta-kms-lease.c
new file mode 100644
index 000000000..c94604878
--- /dev/null
+++ b/src/backends/native/meta-kms-lease.c
@@ -0,0 +1,791 @@
+/*
+ * Copyright (C) 2023 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include "backends/native/meta-kms-lease.h"
+
+#include <glib.h>
+
+#include "backends/native/meta-crtc-kms.h"
+#include "backends/native/meta-kms.h"
+#include "backends/native/meta-kms-connector.h"
+#include "backends/native/meta-kms-crtc-private.h"
+#include "backends/native/meta-kms-device.h"
+#include "backends/native/meta-kms-plane.h"
+
+enum
+{
+  PROP_0,
+
+  PROP_MANAGER_BACKEND_NATIVE,
+
+  N_PROPS_MANAGER,
+};
+
+static GParamSpec *props_manager[N_PROPS_MANAGER] = { NULL };
+
+enum
+{
+  MANAGER_CONNECTORS_CHANGED,
+
+  N_SIGNALS_MANAGER,
+};
+
+static guint signals_manager[N_SIGNALS_MANAGER] = { 0 };
+
+enum
+{
+  LEASE_REVOKED,
+
+  N_SIGNALS_LEASE,
+};
+
+static guint signals_lease[N_SIGNALS_LEASE] = { 0 };
+
+struct _MetaKmsLeaseManager
+{
+  GObject parent;
+
+  MetaBackendNative *backend_native;
+
+  gulong device_added_handler_id;
+  gulong resources_changed_handler_id;
+  gulong lease_changed_handler_id;
+
+  GHashTable *leases;
+  GHashTable *connectors;
+};
+
+G_DEFINE_TYPE (MetaKmsLeaseManager, meta_kms_lease_manager, G_TYPE_OBJECT)
+
+typedef struct _LeasingKmsAssignment
+{
+  MetaKmsConnector *connector;
+  MetaKmsCrtc *crtc;
+  MetaKmsPlane *primary_plane;
+  MetaKmsPlane *cursor_plane;
+} LeasingKmsAssignment;
+
+struct _MetaKmsLease
+{
+  GObject parent;
+
+  uint32_t lessee_id;
+  int fd;
+  MetaKmsDevice *kms_device;
+  GList *assignments;
+};
+
+G_DEFINE_TYPE (MetaKmsLease, meta_kms_lease, G_TYPE_OBJECT)
+
+static MetaKmsCrtc *
+find_crtc_to_lease (MetaKmsConnector *kms_connector)
+{
+  MetaKmsDevice *device = meta_kms_connector_get_device (kms_connector);
+  const MetaKmsConnectorState *connector_state =
+    meta_kms_connector_get_current_state (kms_connector);
+  GList *l;
+
+  for (l = meta_kms_device_get_crtcs (device); l; l = l->next)
+    {
+      MetaKmsCrtc *kms_crtc = l->data;
+      MetaCrtcKms *crtc_kms = meta_crtc_kms_from_kms_crtc (kms_crtc);
+      uint32_t crtc_idx;
+
+      if (meta_crtc_is_leased (META_CRTC (crtc_kms)))
+        continue;
+
+      if (meta_crtc_get_outputs (META_CRTC (crtc_kms)) != NULL)
+        continue;
+
+      crtc_idx = meta_kms_crtc_get_idx (kms_crtc);
+      if (!(connector_state->common_possible_crtcs & (1 << crtc_idx)))
+        continue;
+
+      return kms_crtc;
+    }
+
+  return NULL;
+}
+
+static gboolean
+is_plane_assigned (MetaKmsDevice *kms_device,
+                   MetaKmsPlane  *kms_plane)
+{
+  GList *l;
+
+  for (l = meta_kms_device_get_crtcs (kms_device); l; l = l->next)
+    {
+      MetaKmsCrtc *kms_crtc = l->data;
+      MetaCrtcKms *crtc_kms = meta_crtc_kms_from_kms_crtc (kms_crtc);
+
+      if (meta_crtc_kms_get_assigned_primary_plane (crtc_kms) == kms_plane)
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
+static MetaKmsPlane *
+find_plane_to_lease (MetaKmsCrtc      *kms_crtc,
+                     MetaKmsPlaneType  plane_type)
+{
+  MetaKmsDevice *kms_device = meta_kms_crtc_get_device (kms_crtc);
+  GList *l;
+
+  for (l = meta_kms_device_get_planes (kms_device); l; l = l->next)
+    {
+      MetaKmsPlane *kms_plane = l->data;
+
+      if (meta_kms_plane_get_plane_type (kms_plane) != plane_type)
+        continue;
+
+      if (!meta_kms_plane_is_usable_with (kms_plane, kms_crtc))
+        continue;
+
+      if (is_plane_assigned (kms_device, kms_plane))
+        continue;
+
+      return kms_plane;
+    }
+
+  return NULL;
+}
+
+static MetaKmsDevice *
+find_resources_to_lease (GList   *connectors,
+                         GList  **out_assignments,
+                         GList  **out_crtcs,
+                         GList  **out_planes,
+                         GError **error)
+{
+  MetaKmsDevice *kms_device = NULL;
+  g_autoptr (GList) assignments = NULL;
+  g_autoptr (GList) crtcs = NULL;
+  g_autoptr (GList) planes = NULL;
+  GList *l;
+
+  if (connectors == NULL)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   "Cannot create lease without connectors");
+      return NULL;
+    }
+
+  for (l = connectors; l; l = l->next)
+    {
+      MetaKmsConnector *connector = l->data;
+      MetaKmsDevice *connector_device;
+
+      connector_device =
+        meta_kms_connector_get_device (connector);
+
+      if (kms_device != NULL && kms_device != connector_device)
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                       "Cannot create lease on multiple devices");
+          return NULL;
+        }
+
+      kms_device = connector_device;
+    }
+
+  for (l = connectors; l; l = l->next)
+    {
+      MetaKmsConnector *connector = l->data;
+      LeasingKmsAssignment *assignment;
+      MetaKmsCrtc *crtc;
+      MetaKmsPlane *primary_plane;
+      MetaKmsPlane *cursor_plane;
+
+      crtc = find_crtc_to_lease (connector);
+      if (!crtc)
+        {
+           g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                        "Failed to find CRTC to lease with connector %u (%s)",
+                        meta_kms_connector_get_id (connector),
+                        meta_kms_device_get_path (kms_device));
+          return NULL;
+        }
+
+      crtcs = g_list_append (crtcs, crtc);
+
+      primary_plane = find_plane_to_lease (crtc, META_KMS_PLANE_TYPE_PRIMARY);
+      if (!primary_plane)
+        {
+           g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                        "Failed to find primary plane "
+                        "to lease with connector %u (%s)",
+                        meta_kms_connector_get_id (connector),
+                        meta_kms_device_get_path (kms_device));
+          return NULL;
+        }
+
+      planes = g_list_append (planes, primary_plane);
+
+      cursor_plane = find_plane_to_lease (crtc, META_KMS_PLANE_TYPE_CURSOR);
+      if (!cursor_plane)
+        {
+          g_warning ("Failed to find cursor plane "
+                     "to lease with connector %u (%s)",
+                     meta_kms_connector_get_id (connector),
+                     meta_kms_device_get_path (kms_device));
+        }
+      else
+        {
+          planes = g_list_append (planes, cursor_plane);
+        }
+
+      assignment = g_new0 (LeasingKmsAssignment, 1);
+      assignment->connector = connector;
+      assignment->crtc = crtc;
+      assignment->primary_plane = primary_plane;
+      assignment->cursor_plane = cursor_plane;
+
+      assignments = g_list_append (assignments, assignment);
+    }
+
+  *out_assignments = g_steal_pointer (&assignments);
+  *out_crtcs = g_steal_pointer (&crtcs);
+  *out_planes = g_steal_pointer (&planes);
+  return kms_device;
+}
+
+uint32_t
+meta_kms_lease_get_id (MetaKmsLease *lease)
+{
+  return lease->lessee_id;
+}
+
+int
+meta_kms_lease_steal_fd (MetaKmsLease *lease)
+{
+  int fd = lease->fd;
+  lease->fd = -1;
+  return fd;
+}
+
+gboolean
+meta_kms_lease_is_active (MetaKmsLease *lease)
+{
+  return lease->lessee_id != 0;
+}
+
+static void
+meta_kms_lease_assign (MetaKmsLease *lease)
+{
+  GList *l;
+
+  for (l = lease->assignments; l; l = l->next)
+    {
+      LeasingKmsAssignment *assignment = l->data;
+      MetaCrtcKms *crtc_kms = meta_crtc_kms_from_kms_crtc (assignment->crtc);
+
+      meta_kms_crtc_set_is_leased (assignment->crtc, TRUE);
+      meta_crtc_kms_assign_plane (crtc_kms,
+                                  assignment->primary_plane,
+                                  assignment->cursor_plane);
+    }
+}
+
+static void
+meta_kms_lease_unassign (MetaKmsLease *lease)
+{
+  GList *l;
+
+  for (l = lease->assignments; l; l = l->next)
+    {
+      LeasingKmsAssignment *assignment = l->data;
+      MetaCrtcKms *crtc_kms = meta_crtc_kms_from_kms_crtc (assignment->crtc);
+
+      meta_kms_crtc_set_is_leased (assignment->crtc, FALSE);
+      meta_crtc_kms_assign_plane (crtc_kms, NULL, NULL);
+    }
+}
+
+static void
+mark_revoked (MetaKmsLease *lease)
+{
+  meta_kms_lease_unassign (lease);
+
+  g_signal_emit (lease, signals_lease[LEASE_REVOKED], 0);
+  lease->lessee_id = 0;
+}
+
+void
+meta_kms_lease_revoke (MetaKmsLease *lease)
+{
+  g_autoptr (GError) error;
+
+  if (!lease->lessee_id)
+    return;
+
+  if (!meta_kms_device_revoke_lease (lease->kms_device, lease->lessee_id, &error))
+    {
+      g_warning ("Failed to revoke DRM lease on %s: %s",
+                 meta_kms_device_get_path (lease->kms_device),
+                 error->message);
+      return;
+    }
+
+  mark_revoked (lease);
+}
+
+static void
+meta_kms_lease_disappeared (MetaKmsLease *lease)
+{
+  mark_revoked (lease);
+}
+
+static void
+meta_kms_lease_dispose (GObject *object)
+{
+  MetaKmsLease *lease = META_KMS_LEASE (object);
+
+  g_clear_object (&lease->kms_device);
+
+  if (lease->assignments)
+    {
+      g_list_free_full (lease->assignments, g_free);
+      lease->assignments = NULL;
+    }
+
+  G_OBJECT_CLASS (meta_kms_lease_parent_class)->dispose (object);
+}
+
+static void
+meta_kms_lease_finalize (GObject *object)
+{
+  MetaKmsLease *lease = META_KMS_LEASE (object);
+
+  close (lease->fd);
+
+  G_OBJECT_CLASS (meta_kms_lease_parent_class)->finalize (object);
+}
+
+static void
+meta_kms_lease_class_init (MetaKmsLeaseClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->dispose = meta_kms_lease_dispose;
+  object_class->finalize = meta_kms_lease_finalize;
+
+  signals_lease[LEASE_REVOKED] =
+    g_signal_new ("revoked",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+}
+
+static void
+meta_kms_lease_init (MetaKmsLease *lease)
+{
+}
+
+static void
+on_lease_revoked (MetaKmsLease        *lease,
+                  MetaKmsLeaseManager *lease_manager)
+{
+  GHashTableIter iter;
+  MetaKmsConnector *connector;
+  MetaKmsLease *other_lease;
+
+  g_signal_handlers_disconnect_by_func (lease,
+                                        on_lease_revoked,
+                                        lease_manager);
+
+  g_hash_table_iter_init (&iter, lease_manager->connectors);
+  while (g_hash_table_iter_next (&iter,
+                                 (gpointer *)&connector,
+                                 (gpointer *)&other_lease))
+    {
+      if (lease == other_lease)
+        g_hash_table_insert (lease_manager->connectors, connector, NULL);
+    }
+
+  g_hash_table_remove (lease_manager->leases,
+                       GUINT_TO_POINTER (lease->lessee_id));
+
+  g_signal_emit (lease_manager, signals_manager[MANAGER_CONNECTORS_CHANGED], 0);
+}
+
+MetaKmsLease *
+meta_kms_lease_manager_lease_connectors (MetaKmsLeaseManager  *lease_manager,
+                                         GList                *connectors,
+                                         GError              **error)
+{
+  MetaKmsLease *lease;
+  g_autoptr (GList) assignments = NULL;
+  g_autoptr (GList) crtcs = NULL;
+  g_autoptr (GList) planes = NULL;
+  MetaKmsDevice *kms_device = NULL;
+  int fd;
+  uint32_t lessee_id;
+  GList *l;
+
+  kms_device = find_resources_to_lease (connectors,
+                                        &assignments,
+                                        &crtcs,
+                                        &planes,
+                                        error);
+  if (!kms_device)
+    return NULL;
+
+  if (!meta_kms_device_lease_objects (kms_device,
+                                      connectors, crtcs, planes,
+                                      &fd, &lessee_id,
+                                      error))
+    return NULL;
+
+  // FIXME: do we need to ref all the objects?
+  lease = g_object_new (META_TYPE_KMS_LEASE, NULL);
+  lease->lessee_id = lessee_id;
+  lease->fd = fd;
+  lease->kms_device = g_object_ref (kms_device);
+  lease->assignments = g_steal_pointer (&assignments);
+
+  meta_kms_lease_assign (lease);
+
+  g_signal_connect_after (lease, "revoked", G_CALLBACK (on_lease_revoked),
+                          lease_manager);
+
+  for (l = connectors; l; l = l->next)
+    {
+      MetaKmsConnector *connector = l->data;
+
+      g_hash_table_insert (lease_manager->connectors,
+                           connector, lease);
+    }
+
+  g_hash_table_insert (lease_manager->leases,
+                       GUINT_TO_POINTER (lessee_id), g_object_ref (lease));
+
+  g_signal_emit (lease_manager,
+                 signals_manager[MANAGER_CONNECTORS_CHANGED], 0);
+
+  return lease;
+}
+
+GList *
+meta_kms_lease_manager_get_connectors (MetaKmsLeaseManager *lease_manager)
+{
+  return g_hash_table_get_keys (lease_manager->connectors);
+}
+
+MetaKmsConnector *
+meta_kms_lease_manager_get_connector_from_id (MetaKmsLeaseManager *lease_manager,
+                                              uint32_t             connector_id)
+{
+  GHashTableIter iter;
+  MetaKmsConnector *connector;
+
+  g_hash_table_iter_init (&iter, lease_manager->connectors);
+  while (g_hash_table_iter_next (&iter, (gpointer *)&connector, NULL))
+    {
+      if (meta_kms_connector_get_id (connector) == connector_id)
+        return connector;
+    }
+
+  return NULL;
+}
+
+MetaKmsLease *
+meta_kms_lease_manager_get_lease_from_connector (MetaKmsLeaseManager *lease_manager,
+                                                 MetaKmsConnector    *kms_connector)
+{
+  return g_hash_table_lookup (lease_manager->connectors, kms_connector);
+}
+
+
+
+MetaKmsLease *
+meta_kms_lease_manager_get_lease_from_id (MetaKmsLeaseManager *lease_manager,
+                                          uint32_t             lessee_id)
+{
+  return g_hash_table_lookup (lease_manager->leases,
+                              GUINT_TO_POINTER (lessee_id));
+}
+
+static void
+update_connectors (MetaKmsLeaseManager *lease_manager)
+{
+  MetaKms *kms = meta_backend_native_get_kms (lease_manager->backend_native);
+  GHashTable *new_connectors;
+  MetaKmsLease *lease;
+  GList *l;
+  GList *o;
+  gboolean has_new = FALSE;
+
+  new_connectors = g_hash_table_new_similar (lease_manager->connectors);
+
+  for (l = meta_kms_get_devices (kms); l; l = l->next)
+    {
+      MetaKmsDevice *kms_device = l->data;
+
+      for (o = meta_kms_device_get_connectors (kms_device); o; o = o->next)
+        {
+          MetaKmsConnector *kms_connector = o->data;
+
+          if (!meta_kms_connector_is_for_lease (kms_connector))
+            continue;
+
+          if (!g_hash_table_steal_extended (lease_manager->connectors,
+                                            kms_connector,
+                                            NULL, (gpointer *) &lease))
+            has_new = TRUE;
+          g_hash_table_insert (new_connectors, kms_connector, lease);
+        }
+    }
+
+  if (has_new || g_hash_table_size (lease_manager->connectors) != 0)
+    {
+      g_signal_emit (lease_manager,
+                     signals_manager[MANAGER_CONNECTORS_CHANGED], 0);
+    }
+
+  g_clear_pointer (&lease_manager->connectors, g_hash_table_unref);
+  lease_manager->connectors = new_connectors;
+}
+
+static void
+lease_disappeared (MetaKmsLeaseManager *lease_manager,
+                   MetaKmsLease        *lease)
+{
+  GList *l;
+
+  for (l = lease->assignments; l; l = l->next)
+    {
+      LeasingKmsAssignment *assignment = l->data;
+      MetaKmsConnector *kms_connector = assignment->connector;
+
+      if (g_hash_table_lookup_extended (lease_manager->connectors,
+                                        kms_connector,
+                                        NULL, NULL))
+        g_hash_table_insert (lease_manager->connectors, kms_connector, NULL);
+    }
+
+  meta_kms_lease_disappeared (lease);
+}
+
+static gboolean
+did_lease_disappear (MetaKmsLease  *lease,
+                     uint32_t      *lessees,
+                     int            num_lessees,
+                     MetaKmsDevice *kms_device)
+{
+  int i;
+
+  if (lease->kms_device != kms_device)
+    return FALSE;
+
+  for (i = 0; i < num_lessees; i++)
+    {
+      if (lease->lessee_id == lessees[i])
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+static void
+update_leases (MetaKmsLeaseManager *lease_manager)
+{
+  MetaKms *kms = meta_backend_native_get_kms (lease_manager->backend_native);
+  MetaKmsLease *lease;
+  GList *l;
+  g_autoptr (GList) disappeared_leases = NULL;
+
+  for (l = meta_kms_get_devices (kms); l; l = l->next)
+    {
+      MetaKmsDevice *kms_device = l->data;
+      g_autofree uint32_t *lessees = NULL;
+      int num_lessees;
+      g_autoptr (GError) error = NULL;
+      GHashTableIter iter;
+
+      if (!meta_kms_device_list_lessees (kms_device,
+                                         &lessees, &num_lessees,
+                                         &error))
+        {
+          g_warning ("Failed to list leases: %s", error->message);
+          continue;
+        }
+
+      g_hash_table_iter_init (&iter, lease_manager->leases);
+      while (g_hash_table_iter_next (&iter, NULL, (gpointer *)&lease))
+        {
+            if (did_lease_disappear (lease, lessees, num_lessees, kms_device))
+              disappeared_leases = g_list_append (disappeared_leases, lease);
+        }
+
+      g_free (lessees);
+    }
+
+  for (l = disappeared_leases; l; l = l->next)
+    {
+      lease = l->data;
+
+      lease_disappeared (lease_manager, lease);
+    }
+}
+
+static void
+on_device_added (MetaKms             *kms,
+                 MetaKmsDevice       *kms_device,
+                 MetaKmsLeaseManager *lease_manager)
+{
+  update_connectors (lease_manager);
+}
+
+static void
+on_resources_changed (MetaKms                *kms,
+                      MetaKmsResourceChanges  changes,
+                      MetaKmsLeaseManager    *lease_manager)
+{
+  if (changes != META_KMS_RESOURCE_CHANGE_FULL)
+    return;
+
+  update_connectors (lease_manager);
+}
+
+static void
+on_lease_changed (MetaKms             *kms,
+                  MetaKmsLeaseManager *lease_manager)
+{
+  update_leases (lease_manager);
+}
+
+static void
+meta_kms_lease_manager_constructed (GObject *object)
+{
+  MetaKmsLeaseManager *lease_manager = META_KMS_LEASE_MANAGER (object);
+  MetaKms *kms = meta_backend_native_get_kms (lease_manager->backend_native);
+
+  lease_manager->device_added_handler_id =
+    g_signal_connect (kms, "device-added",
+                      G_CALLBACK (on_device_added),
+                      lease_manager);
+  lease_manager->resources_changed_handler_id =
+    g_signal_connect (kms, "resources-changed",
+                      G_CALLBACK (on_resources_changed),
+                      lease_manager);
+  lease_manager->lease_changed_handler_id =
+    g_signal_connect (kms, "lease-changed",
+                      G_CALLBACK (on_lease_changed),
+                      lease_manager);
+
+  lease_manager->leases =
+    g_hash_table_new_full (NULL, NULL,
+                           NULL,
+                           (GDestroyNotify) g_object_unref);
+
+  lease_manager->connectors =
+    g_hash_table_new_full (NULL, NULL,
+                           NULL, NULL);
+
+  update_connectors (lease_manager);
+
+  G_OBJECT_CLASS (meta_kms_lease_manager_parent_class)->constructed (object);
+}
+
+static void
+meta_kms_lease_manager_set_property (GObject      *object,
+                                     guint         prop_id,
+                                     const GValue *value,
+                                     GParamSpec   *pspec)
+{
+  MetaKmsLeaseManager *lease_manager = META_KMS_LEASE_MANAGER (object);
+  switch (prop_id)
+    {
+    case PROP_MANAGER_BACKEND_NATIVE:
+      lease_manager->backend_native = g_value_get_object (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+meta_kms_lease_manager_get_property (GObject    *object,
+                                     guint       prop_id,
+                                     GValue     *value,
+                                     GParamSpec *pspec)
+{
+  MetaKmsLeaseManager *lease_manager = META_KMS_LEASE_MANAGER (object);
+  switch (prop_id)
+    {
+    case PROP_MANAGER_BACKEND_NATIVE:
+      g_value_set_object (value, lease_manager->backend_native);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+meta_kms_lease_manager_dispose (GObject *object)
+{
+  MetaKmsLeaseManager *lease_manager = META_KMS_LEASE_MANAGER (object);
+  MetaKms *kms = meta_backend_native_get_kms (lease_manager->backend_native);
+
+  g_clear_signal_handler (&lease_manager->device_added_handler_id, kms);
+  g_clear_signal_handler (&lease_manager->resources_changed_handler_id, kms);
+  g_clear_signal_handler (&lease_manager->lease_changed_handler_id, kms);
+
+  g_clear_pointer (&lease_manager->leases, g_hash_table_unref);
+  g_clear_pointer (&lease_manager->connectors, g_hash_table_unref);
+
+  G_OBJECT_CLASS (meta_kms_lease_manager_parent_class)->dispose (object);
+}
+
+static void
+meta_kms_lease_manager_class_init (MetaKmsLeaseManagerClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->constructed = meta_kms_lease_manager_constructed;
+  object_class->set_property = meta_kms_lease_manager_set_property;
+  object_class->get_property = meta_kms_lease_manager_get_property;
+  object_class->dispose = meta_kms_lease_manager_dispose;
+
+  props_manager[PROP_MANAGER_BACKEND_NATIVE] =
+    g_param_spec_object ("backend-native", NULL, NULL,
+                         META_TYPE_BACKEND_NATIVE,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
+
+  g_object_class_install_properties (object_class,
+                                     N_PROPS_MANAGER, props_manager);
+
+  signals_manager[MANAGER_CONNECTORS_CHANGED] =
+    g_signal_new ("connectors-changed",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+}
+
+static void
+meta_kms_lease_manager_init (MetaKmsLeaseManager *lease_manager)
+{
+}
diff --git a/src/backends/native/meta-kms-lease.h b/src/backends/native/meta-kms-lease.h
new file mode 100644
index 000000000..4cd569b53
--- /dev/null
+++ b/src/backends/native/meta-kms-lease.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2023 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include <glib-object.h>
+
+#include "backends/native/meta-backend-native.h"
+
+#define META_TYPE_KMS_LEASE (meta_kms_lease_get_type ())
+G_DECLARE_FINAL_TYPE (MetaKmsLease, meta_kms_lease,
+                      META, KMS_LEASE, GObject)
+
+#define META_TYPE_KMS_LEASE_MANAGER (meta_kms_lease_manager_get_type ())
+G_DECLARE_FINAL_TYPE (MetaKmsLeaseManager, meta_kms_lease_manager,
+                      META, KMS_LEASE_MANAGER, GObject)
+
+uint32_t meta_kms_lease_get_id (MetaKmsLease *lease);
+
+int meta_kms_lease_steal_fd (MetaKmsLease *lease);
+
+gboolean meta_kms_lease_is_active (MetaKmsLease *lease);
+
+void meta_kms_lease_revoke (MetaKmsLease *lease);
+
+MetaKmsLease * meta_kms_lease_manager_lease_connectors (MetaKmsLeaseManager  *lease_manager,
+                                                        GList                *connectors,
+                                                        GError              **error);
+
+GList * meta_kms_lease_manager_get_connectors (MetaKmsLeaseManager *lease_manager);
+
+MetaKmsConnector * meta_kms_lease_manager_get_connector_from_id (MetaKmsLeaseManager *lease_manager,
+                                                                 uint32_t             connector_id);
+
+MetaKmsLease * meta_kms_lease_manager_get_lease_from_connector (MetaKmsLeaseManager *lease_manager,
+                                                                MetaKmsConnector    *kms_connector);
+
+MetaKmsLease * meta_kms_lease_manager_get_lease_from_id (MetaKmsLeaseManager *lease_manager,
+                                                         uint32_t             lessee_id);
diff --git a/src/backends/native/meta-kms.c b/src/backends/native/meta-kms.c
index 795008b21..0670e54bf 100644
--- a/src/backends/native/meta-kms.c
+++ b/src/backends/native/meta-kms.c
@@ -34,6 +34,8 @@
 enum
 {
   RESOURCES_CHANGED,
+  DEVICE_ADDED,
+  LEASE_CHANGED,
 
   N_SIGNALS
 };
@@ -47,6 +49,7 @@ struct _MetaKms
   MetaKmsFlags flags;
 
   gulong hotplug_handler_id;
+  gulong lease_handler_id;
   gulong removed_handler_id;
 
   MetaKmsImpl *impl;
@@ -307,6 +310,14 @@ on_udev_device_removed (MetaUdev    *udev,
   handle_hotplug_event (kms, NULL, META_KMS_RESOURCE_CHANGE_NONE);
 }
 
+static void
+on_udev_lease (MetaUdev    *udev,
+               GUdevDevice *udev_device,
+               MetaKms     *kms)
+{
+  g_signal_emit (kms, signals[LEASE_CHANGED], 0);
+}
+
 MetaBackend *
 meta_kms_get_backend (MetaKms *kms)
 {
@@ -336,6 +347,8 @@ meta_kms_create_device (MetaKms            *kms,
 
   kms->devices = g_list_append (kms->devices, device);
 
+  g_signal_emit (kms, signals[DEVICE_ADDED], 0, device);
+
   return device;
 }
 
@@ -395,6 +408,8 @@ meta_kms_new (MetaBackend   *backend,
     {
       kms->hotplug_handler_id =
         g_signal_connect (udev, "hotplug", G_CALLBACK (on_udev_hotplug), kms);
+      kms->lease_handler_id =
+        g_signal_connect (udev, "lease", G_CALLBACK (on_udev_lease), kms);
     }
 
   kms->removed_handler_id =
@@ -419,6 +434,7 @@ meta_kms_finalize (GObject *object)
   g_list_free_full (kms->devices, g_object_unref);
 
   g_clear_signal_handler (&kms->hotplug_handler_id, udev);
+  g_clear_signal_handler (&kms->lease_handler_id, udev);
   g_clear_signal_handler (&kms->removed_handler_id, udev);
 
   G_OBJECT_CLASS (meta_kms_parent_class)->finalize (object);
@@ -447,6 +463,23 @@ meta_kms_class_init (MetaKmsClass *klass)
                   G_TYPE_NONE, 1,
                   META_TYPE_KMS_RESOURCE_CHANGES);
 
+  signals[DEVICE_ADDED] =
+    g_signal_new ("device-added",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 1,
+                  META_TYPE_KMS_DEVICE);
+
+  signals[LEASE_CHANGED] =
+    g_signal_new ("lease-changed",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+
   meta_thread_class_register_impl_type (thread_class, META_TYPE_KMS_IMPL);
 }
 
diff --git a/src/backends/native/meta-udev.c b/src/backends/native/meta-udev.c
index 097e8a283..c6974b9c6 100644
--- a/src/backends/native/meta-udev.c
+++ b/src/backends/native/meta-udev.c
@@ -28,6 +28,7 @@
 enum
 {
   HOTPLUG,
+  LEASE,
   DEVICE_ADDED,
   DEVICE_REMOVED,
 
@@ -221,6 +222,9 @@ on_uevent (GUdevClient *client,
 
   if (g_udev_device_get_property_as_boolean (device, "HOTPLUG"))
     g_signal_emit (udev, signals[HOTPLUG], 0, device);
+
+  if (g_udev_device_get_property_as_boolean (device, "LEASE"))
+    g_signal_emit (udev, signals[LEASE], 0, device);
 }
 
 MetaUdev *
@@ -282,6 +286,13 @@ meta_udev_class_init (MetaUdevClass *klass)
                   0, NULL, NULL, NULL,
                   G_TYPE_NONE, 1,
                   G_UDEV_TYPE_DEVICE);
+  signals[LEASE] =
+    g_signal_new ("lease",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0, NULL, NULL, NULL,
+                  G_TYPE_NONE, 1,
+                  G_UDEV_TYPE_DEVICE);
   signals[DEVICE_ADDED] =
     g_signal_new ("device-added",
                   G_TYPE_FROM_CLASS (object_class),
diff --git a/src/meson.build b/src/meson.build
index a8cf7e197..3bc0d46b0 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -220,6 +220,8 @@ mutter_sources = [
   'backends/meta-dbus-session-watcher.c',
   'backends/meta-dbus-session-watcher.h',
   'backends/meta-display-config-shared.h',
+  'backends/meta-drm-leasing-service.c',
+  'backends/meta-drm-leasing-service.h',
   'backends/meta-dnd-private.h',
   'backends/meta-fd-source.c',
   'backends/meta-fd-source.h',
@@ -803,6 +805,8 @@ if have_native_backend
     'backends/native/meta-kms-impl-device.h',
     'backends/native/meta-kms-impl.c',
     'backends/native/meta-kms-impl.h',
+    'backends/native/meta-kms-lease.c',
+    'backends/native/meta-kms-lease.h',
     'backends/native/meta-kms-mode.c',
     'backends/native/meta-kms-mode.h',
     'backends/native/meta-kms-page-flip.c',
@@ -917,6 +921,11 @@ dbus_interfaces = [
     'interface': 'org.gnome.Mutter.DisplayConfig.xml',
     'prefix': 'org.gnome.Mutter.',
   },
+  {
+    'name': 'meta-dbus-drm-lease',
+    'interface': 'org.gnome.Mutter.DrmLease.xml',
+    'prefix': 'org.gnome.Mutter.',
+  },
   {
     'name': 'meta-dbus-idle-monitor',
     'interface': 'org.gnome.Mutter.IdleMonitor.xml',
-- 
2.43.0

